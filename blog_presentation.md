# 智能旅行助手：我的 AI Agent 期末大作业实践记录

> 这是一份关于我如何从零开始构建一个基于多智能体协作的智能旅行助手的学习记录。作为人工智能原理课程的期末大作业，我尝试将课堂上学到的 AI Agent 理论知识付诸实践，在这个过程中踩了不少坑，也收获了很多。希望这份记录能对同样在学习 AI Agent 的同学有所帮助。

---

## 一、关于 AI Agent

### 1.1 什么是 AI Agent？

在开始介绍项目之前，我想先聊聊什么是 AI Agent。

**AI Agent（人工智能体）** 并非新生事物，而是回归了人工智能学科的初心——构建能够模拟人类智能行为的实体。然而，直到大语言模型（LLM）的出现，构建通用 Agent 才真正具备了坚实的认知核心。

简单来说，AI Agent 是：
> 一个以 LLM 为大脑，能够**自主感知环境、进行规划推理、使用工具采取行动**，并拥有记忆以实现复杂目标的智能系统。

它标志着 AI 从被动的"指令响应者"向主动的"任务执行者"的根本性转变。

### 1.2 AI Agent 的核心架构

当前主流的 AI Agent 通常由四大核心模块构成：

| 模块 | 功能 |
|------|------|
| **大脑（Brain）** | 即大语言模型，是 Agent 的认知中枢，负责理解、推理、规划和决策 |
| **规划（Planning）** | 负责将用户的宏大目标分解为一系列具体、可执行的子任务 |
| **工具使用（Tool Use）** | 通过调用外部工具（如搜索引擎、API 接口）来弥补 LLM 自身能力的不足 |
| **记忆（Memory）** | 短期记忆保存当前对话上下文，长期记忆存储关键经验 |

### 1.3 AI Agent 与传统生成式 AI 的区别

这是我在学习过程中最重要的一个认知：

- **传统生成式 AI**（如基础的 ChatGPT）是一个卓越的语言模型，其核心是"**生成**"。它在接收一个输入后，生成一个高质量的输出。
- **AI Agent** 是一个智能系统，其核心是"**行动**"与"**目标达成**"。它将 LLM 作为其认知引擎，但更强调通过"**感知-规划-行动**"的自主循环来完成一个多步骤的复杂任务。

简单来说：生成式 AI 是"一问一答"，而 AI Agent 是"接到任务后自己想办法完成"。

### 1.4 什么是 MCP 协议？

在构建 Agent 的过程中，我接触到了一个重要的概念：**MCP（Model Context Protocol）**。

MCP 是由 Anthropic 团队提出的标准化协议，用于**统一智能体与外部工具/资源的通信方式**。

想象一下，你的智能体需要访问文件系统、数据库、GitHub、地图服务等各种外部服务。传统做法是为每个服务编写专门的适配器，这不仅工作量大，而且难以维护。MCP 通过定义统一的协议规范，让所有服务都能以相同的方式被访问。

**MCP 就像智能体的"USB-C"**——无论你使用什么模型，只要支持 MCP 协议，就能无缝访问相同的工具和资源。

MCP 协议提供了三大核心能力：

| 能力 | 说明 | 示例 |
|------|------|------|
| **Tools（工具）** | 可执行的操作 | 搜索景点、查询天气 |
| **Resources（资源）** | 可读取的数据 | 文件内容、数据库记录 |
| **Prompts（提示）** | 预定义的模板 | 代码审查模板 |

---

## 二、项目背景：为什么做智能旅行助手？

### 2.1 期末大作业的选题思考

作为人工智能原理课程的期末大作业，我希望做一个既能体现所学知识，又有实际应用价值的项目。在思考选题时，我想到了自己规划旅行时的痛苦经历：

1. **信息孤岛与手动整合**：旅游攻略、天气预报、酒店预订、景点门票等关键信息分散在不同的网站和 APP 上。用户必须在多个平台间频繁切换，手动筛选、复制和整合信息。

2. **个性化缺失**：网络上绝大多数旅行攻略都是通用模板，很少能精准匹配用户的个人偏好、预算限制或特定的出行时间。

3. **动态调整困难**：旅行计划常常因天气变化或临时起意而需要调整，但传统规划中景点顺序、交通安排环环相扣，任何微小的改动都可能引发连锁反应。

### 2.2 解决方案：让 AI Agent 来帮忙

基于这些痛点，我决定构建一个**智能旅行助手**。它的目标是：

> 用户只需用自然语言提出宏观需求（例如："我要去北京玩3天，喜欢历史文化，预算中等"），系统便能一站式生成包含景点、餐饮、住宿、预算和地图路线的完整、个性化行程。

这个项目完美契合了 AI Agent 的应用场景——需要**自主规划、工具调用、信息整合**的复杂任务。

---

## 三、技术架构：多智能体协作与 MCP 的实践

### 3.1 为什么需要多智能体？

在设计系统时，我面临一个选择：用一个"全能" Agent 完成所有任务，还是用多个专业 Agent 协作？

经过思考，我选择了**多智能体协作**的方案。原因如下：

1. **单一 Agent 的提示词会非常复杂**，需要同时描述景点搜索、天气查询、酒店推荐、行程规划等多个任务的逻辑，容易出错且难以维护。

2. **专业分工更高效**，就像现实中的旅行社，有专门的景点顾问、酒店顾问和行程规划师，各司其职。

3. **便于调试和扩展**，当某个功能出问题时，可以快速定位到具体的 Agent。

### 3.2 四个 Agent 的角色设计

我设计了四个专门的 Agent，形成一个协作团队：

```
┌─────────────────────────────────────────────────────────────┐
│                      用户请求                                │
│              "北京3天，喜欢历史文化，预算中等"                  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   TripPlannerAgent（协调者）                  │
│                      负责任务分发和结果整合                    │
└─────────────────────────────────────────────────────────────┘
          │                   │                   │
          ▼                   ▼                   ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│ AttractionAgent │ │  WeatherAgent   │ │   HotelAgent    │
│   景点搜索专家   │ │   天气查询专家   │ │   酒店推荐专家   │
│                 │ │                 │ │                 │
│ 调用高德地图API  │ │ 调用天气查询API  │ │ 调用POI搜索API  │
│ 搜索相关景点     │ │ 获取天气预报     │ │ 筛选合适酒店     │
└─────────────────┘ └─────────────────┘ └─────────────────┘
          │                   │                   │
          └───────────────────┼───────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      PlannerAgent                           │
│                      行程规划专家                             │
│                                                             │
│         整合所有信息，生成完整的 JSON 格式旅行计划              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      完整旅行计划                             │
│           包含每日行程、景点、餐饮、住宿、预算                   │
└─────────────────────────────────────────────────────────────┘
```

每个 Agent 的职责：

| Agent | 职责 | 使用的工具 |
|-------|------|-----------|
| **AttractionSearchAgent** | 根据用户偏好搜索景点 | 高德地图 POI 搜索 |
| **WeatherQueryAgent** | 查询目的地天气预报 | 高德天气 API |
| **HotelAgent** | 搜索符合要求的酒店 | 高德地图 POI 搜索 |
| **PlannerAgent** | 整合信息，生成完整行程 | 无（纯 LLM 推理） |

### 3.3 MCP 协议在项目中的应用

这是我在项目中最有收获的部分——通过 MCP 协议调用高德地图服务。

传统方式下，我需要为高德地图的每个 API 编写适配器代码：

```python
# 传统方式：手动集成每个服务
class AmapSearchTool(BaseTool):
    def run(self, keywords, city):
        # 大量的API调用代码...
        pass

class AmapWeatherTool(BaseTool):
    def run(self, city):
        # 天气API调用代码...
        pass
```

而使用 MCP 协议后，代码变得非常简洁：

```python
from hello_agents.tools.builtin.protocol_tools import MCPTool

# 创建 MCP 工具，自动获得高德地图的所有能力
self.mcp_tool = MCPTool(
    name="amap_mcp",
    server_command=["npx", "-y", "@sugarforever/amap-mcp-server"],
    env={"AMAP_API_KEY": amap_api_key}
)

# 添加到 Agent，自动展开为多个工具
self.attraction_agent.add_tool(self.mcp_tool)
```

MCP 服务器会自动提供 16 个工具，包括：
- `amap_maps_text_search` - POI 搜索
- `amap_maps_weather` - 天气查询
- `amap_maps_direction` - 路线规划
- 等等...

Agent 可以像调用普通工具一样使用这些能力：

```
[TOOL_CALL:amap_maps_text_search:keywords=景点,city=北京]
```

### 3.4 系统整体架构

项目采用经典的前后端分离架构：

```
┌─────────────────────────────────────────────────────────────┐
│                    前端层 (Vue3 + TypeScript)                │
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  表单输入    │  │  结果展示    │  │  地图可视化  │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼ HTTP API
┌─────────────────────────────────────────────────────────────┐
│                    后端层 (FastAPI)                          │
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  API路由    │  │  数据验证    │  │  业务逻辑    │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                 智能体层 (HelloAgents)                       │
│                                                             │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐       │
│  │Attraction│ │ Weather  │ │  Hotel   │ │ Planner  │       │
│  │  Agent   │ │  Agent   │ │  Agent   │ │  Agent   │       │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘       │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼ MCP 协议
┌─────────────────────────────────────────────────────────────┐
│                    外部服务层                                │
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │ 高德地图API  │  │ Unsplash   │  │   LLM API   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
```

---

## 四、开发与部署实录：从本地到云端

### 4.1 本地开发：Docker 与 Docker Compose

在本地开发阶段，我使用 Docker 和 Docker Compose 来管理服务。

**后端 Dockerfile** 比较简单，基于 Python 镜像：

```dockerfile
FROM python:3.10-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["python", "run.py"]
```

**前端 Dockerfile** 采用多阶段构建，先用 Node.js 构建，再用 Nginx 部署：

```dockerfile
# Stage 1: Build
FROM node:20-alpine AS build-stage
WORKDIR /app
ARG VITE_API_BASE_URL
ENV VITE_API_BASE_URL=$VITE_API_BASE_URL
COPY package*.json ./
RUN npm install
COPY . .
RUN NODE_OPTIONS=--openssl-legacy-provider npm run build-only

# Stage 2: Production
FROM nginx:stable-alpine
COPY --from=build-stage /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

本地运行一切正常，于是我信心满满地准备部署到云端...

### 4.2 Zeabur 部署踩坑记录

我选择了 Zeabur 作为部署平台，因为它对学生友好，支持一键部署。然而，部署过程远比我想象的曲折。

#### 坑 1：前端被识别为静态网站，返回 404

**问题现象**：前端部署后，访问任何路由都返回 404。

**排查过程**：
- 检查 Zeabur 的部署日志，发现它把我的 Vue 项目识别成了"静态网站"
- 静态网站模式下，Zeabur 不会运行 Dockerfile，而是直接托管静态文件
- 但我的项目需要 Nginx 来处理 SPA 路由

**解决方案**：在 `frontend/` 目录下创建 `zeabur.json` 配置文件，强制指定为 Docker 部署：

```json
{
  "build_type": "dockerfile"
}
```

#### 坑 2：Node.js 版本不兼容，crypto.hash 报错

**问题现象**：前端构建时报错：

```
TypeError: crypto.hash is not a function
```

**排查过程**：
- 这个错误是因为 Vite 5.x 使用了 `crypto.hash()` 方法
- 但这个方法是 Node.js 21+ 才引入的
- Zeabur 默认使用的 Node.js 版本较低

**解决方案**：在 Dockerfile 中明确使用 Node.js 20+，并添加兼容性选项：

```dockerfile
FROM node:20-alpine AS build-stage
# ...
RUN NODE_OPTIONS=--openssl-legacy-provider npm run build-only
```

#### 坑 3：后端服务不稳定

**问题现象**：后端服务偶尔会崩溃或响应超时。

**排查过程**：
- 查看日志发现是 MCP 服务器启动失败
- 原因是 Zeabur 的容器环境没有预装 Node.js 和 npx
- MCP 工具需要通过 `npx` 启动高德地图服务器

**解决方案**：
1. 在后端的 `zeabur.json` 中指定 Python 版本：

```json
{
  "build_command": "pip install -r requirements.txt",
  "start_command": "python run.py",
  "base": "python",
  "python_version": "3.10"
}
```

2. 确保容器中安装了 Node.js（通过在 requirements 或启动脚本中处理）

3. 添加错误处理和重试机制，提高服务稳定性

#### 经验总结

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 前端 404 | 被识别为静态网站 | 添加 `zeabur.json` 指定 dockerfile 构建 |
| crypto.hash 报错 | Node.js 版本过低 | 使用 Node.js 20+ 镜像 |
| 后端不稳定 | MCP 依赖 npx | 确保环境完整，添加错误处理 |

---

## 五、总结与展望

### 5.1 项目收获

通过这个期末大作业，我收获了很多：

1. **理论与实践的结合**：课堂上学到的 AI Agent 概念（感知-规划-行动循环、工具调用、多智能体协作）在实际项目中得到了验证。

2. **工程能力的提升**：从前后端开发、Docker 容器化到云端部署，完整经历了一个项目的全生命周期。

3. **问题解决能力**：部署过程中遇到的各种坑，让我学会了如何排查问题、查阅文档、寻找解决方案。

4. **对 MCP 协议的理解**：MCP 确实是一个很优雅的设计，它让工具集成变得标准化和可复用。

### 5.2 不足与改进方向

当然，项目还有很多可以改进的地方：

1. **响应速度**：目前生成一个旅行计划需要 10-30 秒，可以考虑并行调用多个 Agent 来加速。

2. **结果质量**：LLM 生成的行程有时不够合理，可以加入更多的约束和验证逻辑。

3. **用户体验**：可以添加更多交互功能，如实时编辑、行程分享、多人协作等。

4. **成本优化**：每次请求都要调用多次 LLM API，成本较高，可以考虑缓存和优化策略。

### 5.3 对 AI Agent 未来的思考

通过这个项目，我对 AI Agent 的未来有了一些思考：

- **AI Agent 是通往 AGI 的重要路径**：它让 AI 从"生成内容"进化到"完成任务"，这是一个质的飞跃。

- **多智能体协作是趋势**：就像人类社会的分工协作，让专业的 Agent 做专业的事，比一个"全能" Agent 更高效。

- **标准化协议很重要**：MCP 这样的协议让工具生态可以快速发展，降低了开发者的集成成本。

- **落地应用是关键**：技术再先进，最终还是要解决实际问题。旅行规划只是一个起点，AI Agent 可以应用到更多领域。

---

## 附录：项目演示

### 核心功能展示

1. **首页表单**：用户输入目的地、日期、偏好、预算等信息
2. **加载进度**：显示 Agent 的工作状态（搜索景点 → 查询天气 → 推荐酒店 → 生成计划）
3. **结果页面**：展示完整的旅行计划，包括：
   - 行程概览
   - 预算明细
   - 地图可视化（标注景点位置）
   - 每日行程详情
   - 天气信息
4. **行程编辑**：支持调整景点顺序、删除景点
5. **导出功能**：导出为图片或 PDF

### 技术栈总结

| 层级 | 技术选型 |
|------|----------|
| 前端 | Vue 3 + TypeScript + Ant Design Vue + 高德地图 JS API |
| 后端 | Python + FastAPI + Pydantic |
| 智能体 | HelloAgents 框架 + MCP 协议 |
| 外部服务 | 高德地图 API + Unsplash API + LLM API |
| 部署 | Docker + Zeabur |

---

> 感谢阅读！如果你对这个项目感兴趣，欢迎交流讨论。
> 
> 这是我的第一个 AI Agent 项目，还有很多不足之处，欢迎批评指正。
